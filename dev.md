## 1. 개발 준비 및 문서화

### 1.1. create-next-app으로 프로젝트 생성하기

다음 명령어를 사용하여 새 프로젝트를 생성한다: command prompt에서 원하는 폴더에 가서 아래를 실행한다. 

  

```bash
예를 들어 

C:\Users\user>cd /
C:\>cd web
C:\web>

이후 아래를 실행한다. 

npx create-next-app@latest my_blog

√ Would you like to use TypeScript? ... Yes
√ Would you like to use ESLint? ... Yes
√ Would you like to use Tailwind CSS? ... Yes
√ Would you like your code inside a `src/` directory? ... No
√ Would you like to use App Router? (recommended) ... Yes
√ Would you like to use Turbopack for `next dev`? ... No
√ Would you like to customize the import alias (`@/*` by default)? ... No

cd my_blog
npx shadcn@latest init

# 모든 컴포넌트 설치
npx shadcn@latest add --all --overwrite

# npm 패키지들 한번에 설치
npm install @radix-ui/react-dialog @radix-ui/react-icons lucide-react highlight.js

npm run dev
```

### 1.2. 프로젝트 전역 설정

github copilot으로 작업 시작할 때 아래와 같이 시작한다. 

**프롬프트:**

```
이 프로젝트 진행 과정에서 아래의 사항을 반드시 기억하고 준수한다. 

프로젝트 전역 설정:
- 파일 생성/수정은 command prompt 사용
- 대화는 한글로 진행  
- TypeScript와 한글 주석 사용
- 기본적인 에러 처리 포함
- 초보자도 이해할 수 있는 수준으로 구현
- 복잡한 최적화나 고급 기능은 제외

AI 실수 방지 체크리스트:
✓ Next.js App Router 경로 구조 정확히 사용 (app/ 디렉토리 기준)
✓ 'use client' 지시문 필요한 컴포넌트에만 추가
✓ import 경로는 절대경로(@/) 또는 상대경로 일관성 유지
✓ TypeScript 타입 정의 누락 없이 구현
✓ 존재하지 않는 라이브러리나 컴포넌트 사용 금지
✓ 복잡한 상태 관리나 최적화 기법 사용 금지

이 설정을 기준으로 앞으로 모든 구현을 진행합니다.
```

8장의 내용을 [dev.md](http://dev.md) 파일에 저장한다. 

**프롬프트:**

```
dev.md는 당신이 개발해야할 내용들이 순서대로 기술되어 있다. 검토하고 맥락을 파악한다.
```

### 1.3. 요구사항 문서 작성

AI 주도 개발의 첫 단계는 명확한 요구사항 정의다. 다음 프롬프트를 사용하여 블로그 프로젝트에 대한 요구사항 문서를 작성한다:

**프롬프트:**

```
개인 블로그 프로젝트의 요구사항 문서를 작성해 주세요.

**프로젝트 맥락 정보:**
- 타겟 사용자: 웹 개발에 관심 있는 학생
- 주요 기능: 블로그 포스팅, 카테고리 분류, 댓글 시스템, 검색 기능
- 기술 스택: Next.js, TypeScript, TailwindCSS, ShadCN UI

**구현 대상:**
- 파일 경로: `docs/requirements.md`
- 파일 역할: 프로젝트 전체 요구사항 정의서

**주요 요구사항:**
1. 제품 개요 및 목표 정의
   - 블로그의 목적과 비전 명시
   - 성공 지표 설정

2. 타겟 사용자 정의
   - 주요 사용자 그룹 식별
   - 사용자 니즈 분석

3. 핵심 기능 목록 및 우선순위
   - 블로그 포스트 작성/조회 기능
   - 카테고리 및 태그 시스템
   - 댓글 및 좋아요 기능
   - 검색 및 필터링 기능

4. 사용자 흐름 설계
   - 방문자 → 독자 → 구독자 전환 과정
   - 주요 사용자 시나리오

5. 비기능적 요구사항
   - 성능: 페이지 로딩 시간 3초 이내
   - 접근성: 기본 웹 표준 준수
   - 반응형: 모바일/태블릿/데스크탑 지원

**기술적 요구사항:**
- Markdown 기반 콘텐츠 작성 지원
- SEO 최적화 기본 구조
- 소셜 미디어 공유 기능

**완료 기준:**
- 모든 섹션이 구체적으로 작성됨
- 다음 단계 개발에 필요한 정보 충분히 포함
- 마크다운 형식으로 가독성 확보
```

### 1.4. 프로젝트 구조 설계

요구사항이 정의되면, 다음 프롬프트를 사용하여 프로젝트의 폴더 구조를 설계한다:

**프롬프트:**

```
블로그 프로젝트의 폴더 구조를 설계해 주세요.

**현재 상황:**
- Next.js 15+ App Router 기반 프로젝트
- docs/requirements.md 요구사항 문서 작성 완료
- ShadCN UI 및 TailwindCSS 설치 완료

**구현 대상:**
- 파일 경로: `docs/structure.md`
- 파일 역할: 프로젝트 전체 폴더 구조 가이드

**주요 요구사항:**
1. App Router 기반 라우팅 구조
   - 블로그 포스트 목록 페이지 (`/posts`)
   - 블로그 포스트 상세 페이지 (`/posts/[slug]`)
   - 카테고리별 필터링 페이지 (`/categories/[slug]`)
   - 검색 결과 페이지 (`/search`)

2. 컴포넌트 구조 설계
   - 공통 컴포넌트 (Header, Footer, Layout)
   - 블로그 전용 컴포넌트 (PostCard, CommentSection)
   - UI 컴포넌트 (Button, Card 등 - ShadCN 활용)

3. 데이터 및 유틸리티 구조
   - 타입 정의 파일 (`types/`)
   - 목업 데이터 파일 (`data/`)
   - 유틸리티 함수 (`lib/`)

**기술적 요구사항:**
- 확장 가능한 구조로 설계
- 컴포넌트 재사용성 고려
- 폴더명은 kebab-case 사용
- 파일명은 camelCase 또는 kebab-case 일관성 유지

**완료 기준:**
- 전체 프로젝트 구조가 트리 형태로 명시됨
- 각 폴더와 파일의 역할이 명확히 설명됨
- 향후 확장 시 고려사항 포함

```

### 1.5. 디자인 가이드 및 와이어프레임 작성

사용자 경험을 고려한 디자인 가이드와 와이어프레임을 작성한다:

**디자인 가이드 프롬프트:**

```
블로그 웹사이트의 디자인 가이드를 작성해 주세요.

**프로젝트 맥락 정보:**
- 기술 스택: TailwindCSS, ShadCN UI
- 타겟 사용자: 웹 개발 학습자
- 프로젝트 성격: 개인 기술 블로그

**구현 대상:**
- 파일 경로: `docs/design.md`
- 파일 역할: 디자인 시스템 및 스타일 가이드

**주요 요구사항:**
1. 디자인 컨셉 및 원칙
   - 깔끔하고 읽기 쉬운 디자인
   - 콘텐츠 중심의 미니멀한 레이아웃
   - 전문성과 친근함의 균형

2. 색상 팔레트 및 타이포그래피
   - 주 색상: 브랜드 컬러 정의
   - 보조 색상: 상태별 색상 (성공, 경고, 에러)
   - 중성 색상: 텍스트 및 배경 색상
   - 폰트: 가독성 우선 폰트 선택

3. 주요 페이지 레이아웃
   - 헤더: 로고, 네비게이션, 검색
   - 메인 콘텐츠: 그리드 기반 레이아웃
   - 사이드바: 카테고리, 최신 포스트
   - 푸터: 링크, 저작권 정보

4. UI 컴포넌트 스타일 가이드
   - 버튼: 크기별, 상태별 스타일
   - 카드: 포스트 카드, 카테고리 카드
   - 폼: 입력 필드, 버튼 스타일
   - 네비게이션: 메뉴 스타일

5. 반응형 디자인 지침
   - 브레이크포인트: 모바일(sm), 태블릿(md), 데스크탑(lg)
   - 레이아웃 변화 규칙
   - 모바일 우선 접근법

**기술적 요구사항:**
- TailwindCSS 클래스 기반 스타일링
- ShadCN UI 컴포넌트 활용 방안

**완료 기준:**
- 디자인 시스템이 체계적으로 정리됨
- 개발팀이 참고할 수 있는 구체적 가이드 제공
- TailwindCSS 설정과 연계된 실용적 내용
```

**와이어프레임 프롬프트:**

```
블로그 애플리케이션의 와이어프레임을 생성해 주세요.

**현재 상황:**
- docs/design.md 디자인 가이드 작성 완료
- docs/requirements.md 요구사항 문서 작성 완료

**구현 대상:**
- 파일 경로: `docs/wireframes.md`
- 파일 역할: 주요 페이지별 와이어프레임 설계서

**주요 요구사항:**
1. 메인 페이지 (홈) 와이어프레임
   - Hero 섹션: 블로그 소개
   - 최신 포스트 섹션: 카드 그리드 레이아웃
   - 카테고리 네비게이션

2. 목록 페이지 와이어프레임
   - 페이지 헤더: 제목, 필터링 옵션
   - 포스트 카드 그리드: 3-4열 레이아웃
   - 페이지네이션

3. 상세 페이지 와이어프레임
   - 포스트 헤더: 제목, 메타데이터
   - 콘텐츠 영역: 본문, 이미지
   - 댓글 섹션
   - 관련 포스트 추천

4. 검색 결과 페이지 와이어프레임
   - 검색 박스
   - 결과 목록
   - 필터링 사이드바

**반응형 고려사항:**
- 데스크탑: 멀티 컬럼 레이아웃
- 태블릿: 2컬럼 레이아웃
- 모바일: 싱글 컬럼 레이아웃

**기술적 요구사항:**
- ASCII 아트 또는 텍스트 기반 와이어프레임
- 각 섹션의 크기와 위치 명시
- 인터랙션 포인트 표시

**완료 기준:**
- 모든 주요 페이지 타입의 와이어프레임 완성
- 반응형 변화 포인트 명시
- 개발자가 구현 가능한 수준의 상세도

```

### 1.6. 기술 아키텍처 설계

다음 프롬프트를 사용하여 블로그 웹사이트의 기술 아키텍처를 설계한다:

**프롬프트:**

```
블로그 웹사이트의 기술 아키텍처를 설계해 주세요.

**현재 상황:**
- docs/requirements.md, docs/design.md, docs/wireframes.md 작성 완료
- Next.js 15+ App Router, TypeScript, TailwindCSS 환경 구성

**구현 대상:**
- 파일 경로: `docs/tech-architecture.md`
- 파일 역할: 기술적 구현 방향 및 아키텍처 설계서

**주요 요구사항:**
1. 프로젝트 구조 및 파일 조직
   - 폴더 구조와 네이밍 규칙
   - 파일 분리 및 모듈화 전략
   - 설정 파일 관리 방안

2. 컴포넌트 계층 구조
   - Layout 컴포넌트 설계
   - 재사용 가능한 UI 컴포넌트
   - 페이지별 컴포넌트 구조
   - Props 전달 및 상태 관리 패턴

3. 데이터 모델 및 상태 관리 전략
   - 블로그 포스트 데이터 구조
   - 카테고리 및 태그 모델
   - 클라이언트 상태 관리 (useState, useEffect)
   - 목업 데이터 구조 및 관리

4. 라우팅 및 네비게이션
   - App Router 활용 전략
   - 동적 라우팅 구현 방안
   - SEO 최적화를 위한 메타데이터 설정

5. 성능 최적화 전략
   - Next.js Image 컴포넌트 활용
   - 코드 스플리팅 기본 적용
   - 기본적인 캐싱 전략

**기술적 제약사항:**
- 복잡한 상태 관리 라이브러리 사용 금지
- 데이터베이스 연동은 향후 장에서 구현
- 현재는 정적 데이터 및 로컬 스토리지 활용

**완료 기준:**
- 전체 시스템 아키텍처가 명확히 정의됨
- 구현 단계별 가이드라인 제공
- 향후 확장성 고려사항 포함

```

### 1.7. 데이터 모델 및 목업 데이터 생성

다음 프롬프트를 사용하여 블로그 포스트의 데이터 모델과 목업 데이터를 생성한다:

**프롬프트:**

```
블로그 애플리케이션의 데이터 모델과 목업 데이터를 생성해 주세요.

**현재 상황:**
- 기술 아키텍처 설계 완료
- TypeScript 환경에서 타입 안전성 확보 필요

**구현 대상:**
- 파일 경로: `data/mockData.ts`
- 파일 역할: 타입 정의 및 샘플 데이터 제공

**주요 요구사항:**
1. 핵심 인터페이스 정의
   - BlogPost: 블로그 포스트 완전한 데이터 구조
   - Author: 작성자 정보 (향후 인증 시스템 연동 고려)
   - Category: 카테고리 분류 체계
   - Comment: 댓글 시스템 (향후 구현 예정)

2. BlogPost 인터페이스 상세 설계
   - 기본 정보: id, title, slug, content, excerpt
   - 메타데이터: publishedAt, updatedAt, readingTime
   - 미디어: coverImage, images
   - 분류: category, tags
   - 상호작용: viewCount, likeCount, featured

3. 샘플 데이터 생성
   - 최소 5개의 완성된 블로그 포스트
   - 다양한 카테고리 (웹 개발, JavaScript, React 등)
   - 현실적인 콘텐츠 길이와 구조
   - 한글과 영어 혼용 자연스러운 제목

4. 데이터 검증 및 유틸리티
   - 타입 가드 함수
   - 데이터 필터링 유틸리티
   - 정렬 및 검색 도우미 함수

**기술적 요구사항:**
- TypeScript 인터페이스 완전 활용
- 확장 가능한 데이터 구조 설계
- 실제 CMS 연동을 고려한 필드 구성
- JSDoc 주석으로 타입 설명 추가

**완료 기준:**
- 모든 인터페이스가 실제 사용 가능한 수준으로 완성
- 5개 이상의 현실적인 샘플 데이터
- 다음 구현 단계에서 즉시 활용 가능

```

## 2. 단계별 블로그 구현 프로세스

개발을 진행하면서 새로운 모듈 설치가 필요하면 터미널에서 직접 설치하고 "설치 완료, 계속 진행" 안내를 한다.

**맥락 설정 프롬프트:**

```
Next.js 기반 블로그 프로젝트의 구현을 시작합니다.

**프로젝트 맥락 정보:**
- 기술 스택: Next.js 15+ App Router, TypeScript, TailwindCSS, ShadCN UI
- 완성된 설계 문서: requirements.md, structure.md, design.md, wireframes.md, tech-architecture.md
- 현재 단계: 실제 컴포넌트 구현 시작

**기존 구현 사항:**
- 프로젝트 초기 설정 완료
- 설계 문서 작성 완료
- 데이터 모델 및 목업 데이터 생성 완료

**다음 구현 목표:**
- 기본 레이아웃 구조 (Header, Footer, Layout)
- 블로그 포스트 목록 페이지
- 블로그 포스트 상세 페이지
- 기본 검색 기능
- 댓글 시스템 (로컬 스토리지 기반)
- 좋아요 기능

앞으로 단계별로 구현을 진행하겠습니다.
```

### 2.1. 1단계: 기본 레이아웃 구현 및 검증

이 단계에서는 블로그의 기본 레이아웃을 구현한다.

**루트 레이아웃 구현 프롬프트:**

```
블로그 애플리케이션의 루트 레이아웃을 구현해 주세요.

**현재 상황:**
- Next.js 15+ App Router 환경
- TailwindCSS, ShadCN UI 설정 완료
- docs/design.md 디자인 가이드라인 작성 완료

**구현 대상:**
- 파일 경로: `app/layout.tsx`
- 파일 역할: 애플리케이션 전역 레이아웃 및 설정

**주요 요구사항:**
1. 기본 HTML 구조 설정
   - HTML lang 속성 설정 ("ko")
   - 기본 메타데이터 (title, description, favicon)
   - Viewport 설정 및 반응형 지원

2. 전역 스타일 및 폰트 설정
   - globals.css 임포트
   - next/font를 활용한 최적화된 폰트 로드
   - Inter 또는 Noto Sans KR 폰트 적용

3. 공통 레이아웃 구조
   - Header 컴포넌트 배치
   - main 콘텐츠 영역 설정
   - Footer 컴포넌트 배치
   - 최대 너비 제한 및 중앙 정렬

4. SEO 기본 설정
   - 기본 메타데이터 구성
   - Open Graph 기본 설정
   - 구조화된 데이터 준비

**기술적 요구사항:**
- TypeScript 타입 안전성 확보
- RootLayout 컴포넌트 정의
- children prop 올바른 타입 지정
- 성능 최적화를 위한 기본 설정

**완료 기준:**
- 모든 페이지에서 일관된 레이아웃 제공
- Header, Footer 컴포넌트 정상 로드
- 반응형 레이아웃 기본 동작 확인

```

**헤더 컴포넌트 구현 프롬프트:**

```
블로그 헤더 및 네비게이션 컴포넌트를 구현해 주세요.

**현재 상황:**
- app/layout.tsx 루트 레이아웃 구현 완료
- docs/design.md 및 docs/wireframes.md 참고 가능

**구현 대상:**
- 파일 경로: `components/common/header.tsx`
- 파일 역할: 네비게이션 및 브랜딩 제공

**주요 요구사항:**
1. 헤더 레이아웃 구성
   - 로고/브랜드명 (좌측): 텍스트 기반 로고
   - 네비게이션 메뉴 (중앙): 홈, 블로그, 카테고리, About
   - 검색 버튼 (우측): 돋보기 아이콘

2. 반응형 네비게이션
   - 데스크탑: 전체 메뉴 표시
   - 태블릿: 축소된 메뉴
   - 모바일: 햄버거 메뉴 (ShadCN Sheet 컴포넌트 활용)

3. 인터랙션 구현
   - 현재 페이지 활성 상태 표시
   - 호버 효과 및 포커스 스타일
   - 모바일 메뉴 열기/닫기 애니메이션

4. 접근성 고려사항
   - 키보드 네비게이션 지원
   - 시맨틱 HTML 구조 (nav, header 태그)
   - ARIA 레이블 적절한 적용

**기술적 요구사항:**
- 'use client' 지시문 사용 (상태 관리 필요)
- ShadCN UI 컴포넌트 활용 (Sheet, Button)
- Lucide React 아이콘 사용
- Next.js Link 컴포넌트로 네비게이션

**완료 기준:**
- 모든 화면 크기에서 적절한 네비게이션 제공
- 클릭/터치 인터랙션 정상 동작
- 현재 페이지 상태 표시 정확

```

**푸터 컴포넌트 구현 프롬프트:**

```
블로그 푸터 컴포넌트를 구현해 주세요.

**현재 상황:**
- Header 컴포넌트 구현 완료
- 전체 레이아웃 구조 기본 틀 완성

**구현 대상:**
- 파일 경로: `components/common/footer.tsx`
- 파일 역할: 사이트 정보 및 부가 링크 제공

**주요 요구사항:**
1. 푸터 레이아웃 구성
   - 좌측: 저작권 정보 (사이트명, 연도, 저작권 표시)
   - 우측: 간단한 네비게이션 링크

2. 반응형 디자인
   - 데스크탑/태블릿: 2열 레이아웃
   - 모바일: 1열 레이아웃 (저작권 위, 링크 아래)

3. 스타일링
   - 상단 구분선
   - 충분한 여백 설정
   - 텍스트 대비 적절한 색상

4. 동적 연도 표시
   - JavaScript Date 객체로 현재 연도 자동 표시

**기술적 요구사항:**
- 서버 컴포넌트로 구현 (정적 콘텐츠)
- TailwindCSS만 사용하여 스타일링
- Next.js Link 컴포넌트 사용

**완료 기준:**
- 모든 페이지 하단에 일관된 푸터 표시
- 반응형 레이아웃 적절한 동작
- 링크들이 올바른 페이지로 연결

```

**홈페이지 구현 프롬프트:**

```
블로그 홈페이지를 구현해 주세요.

**현재 상황:**
- 기본 레이아웃 (Header, Footer) 구현 완료
- data/mockData.ts 데이터 모델 및 샘플 데이터 준비 완료

**구현 대상:**
- 파일 경로: `app/page.tsx`
- 파일 역할: 블로그 메인 랜딩 페이지

**주요 요구사항:**
1. Hero 섹션
   - 블로그 제목 및 간단한 소개
   - CTA 버튼 (블로그 보러가기)
   - 시각적으로 매력적인 디자인

2. 최신 포스트 섹션
   - mockData.ts에서 최신 3개 포스트 표시
   - 카드 형태로 레이아웃
   - 제목, 요약, 작성일, 커버 이미지 표시

3. 카테고리 섹션
   - 모든 포스트에서 카테고리 추출
   - 카테고리별 포스트 개수 표시
   - 카테고리별 페이지로 링크 연결

**기술적 요구사항:**
- 서버 컴포넌트로 구현 (정적 데이터 활용)
- mockData.ts에서 데이터 가져오기
- Next.js Link 컴포넌트로 네비게이션
- 반응형 그리드 레이아웃 (TailwindCSS)

**완료 기준:**
- Hero 섹션이 시각적으로 매력적으로 표시
- 최신 포스트가 정확히 3개 표시
- 카테고리 링크가 올바르게 동작
- 모든 화면 크기에서 적절한 레이아웃

```

**카테고리 페이지 구현 프롬프트:**

```
카테고리 목록 및 상세 페이지를 구현해 주세요.

**현재 상황:**
- 홈페이지 구현 완료
- 카테고리 링크 연결 필요

**구현 대상:**
- 파일 경로: `app/categories/page.tsx` (카테고리 목록)
- 파일 경로: `app/categories/[slug]/page.tsx` (카테고리 상세)

**주요 요구사항:**
1. 카테고리 목록 페이지 (`/categories`)
   - 모든 카테고리를 카드 형태로 표시
   - 각 카테고리의 포스트 개수 표시
   - 그리드 레이아웃 (반응형)

2. 카테고리 상세 페이지 (`/categories/[slug]`)
   - 해당 카테고리의 포스트만 필터링하여 표시
   - 카테고리 제목 및 포스트 개수 표시
   - 포스트가 없는 경우 적절한 메시지

3. 동적 라우팅 구현
   - generateStaticParams 함수로 정적 경로 생성
   - URL 파라미터에서 카테고리 slug 추출
   - 존재하지 않는 카테고리 접근 시 404 처리

**기술적 요구사항:**
- 서버 컴포넌트로 구현
- mockData.ts에서 데이터 필터링
- Next.js 동적 라우팅 활용
- TypeScript 타입 안전성 확보

**완료 기준:**
- 카테고리 목록이 올바르게 표시
- 각 카테고리 상세 페이지 정상 접근
- 필터링된 포스트가 정확히 표시
- 404 케이스 적절한 처리

```

### 중간 검증: 기본 레이아웃 테스트

구현된 기본 레이아웃이 올바르게 작동하는지 확인한다:

1. **기본 기능 테스트**
    - 모든 페이지에서 Header, Footer 정상 표시 확인
    - 네비게이션 링크들이 올바른 페이지로 연결되는지 확인
    - 홈페이지의 모든 섹션 정상 표시 확인
2. **반응형 레이아웃 테스트**
    - 데스크탑(1280px 이상): 전체 레이아웃 확인
    - 태블릿(768px-1279px): 중간 크기 레이아웃 확인
    - 모바일(767px 이하): 모바일 레이아웃 및 햄버거 메뉴 확인
3. **사용자 경험 테스트**
    - 로딩 상태 및 에러 처리 기본 동작 확인
    - 키보드 네비게이션 작동 확인
    - 색상 대비 및 가독성 확인

**검증 결과 기록:**

- 통과한 기능과 개선이 필요한 부분 식별
- 다음 단계 진행 전 필수 수정사항 처리

### 2.2. 2단계: 블로그 포스트 목록 페이지 구현 및 검증

블로그 포스트 목록 페이지를 구현한다.

**PostCard 컴포넌트 구현 프롬프트:**

```
블로그 포스트 카드 컴포넌트를 구현해 주세요.

**현재 상황:**
- 기본 레이아웃 구현 완료
- mockData.ts 데이터 구조 정의 완료

**구현 대상:**
- 파일 경로: `components/blog/post-card.tsx`
- 파일 역할: 포스트 목록에서 개별 포스트 표시

**주요 요구사항:**
1. 카드 레이아웃 구성
   - 커버 이미지 (상단)
   - 포스트 제목 및 요약 (중간)
   - 작성자, 작성일, 태그 (하단)
   - 읽기 시간 표시

2. 인터랙션
   - 카드 전체 클릭 시 포스트 상세 페이지로 이동
   - 호버 시 부드러운 애니메이션 효과
   - 태그 클릭 시 해당 카테고리 페이지로 이동

3. 이미지 최적화
   - Next.js Image 컴포넌트 사용
   - 적절한 이미지 크기 및 최적화
   - 이미지 로딩 상태 처리

4. 텍스트 처리
   - 제목이 긴 경우 적절한 줄바꿈
   - 요약 텍스트 길이 제한 (truncate)
   - 날짜 포맷팅 (한국어 형식)

**기술적 요구사항:**
- TypeScript Props 인터페이스 정의
- ShadCN Card 컴포넌트 활용
- TailwindCSS 호버 효과 및 애니메이션
- Next.js Link 컴포넌트로 네비게이션

**완료 기준:**
- 모든 데이터가 올바르게 표시됨
- 클릭 인터랙션 정상 동작
- 다양한 화면 크기에서 적절한 카드 크기
- 이미지가 없는 경우도 적절히 처리

```

**포스트 목록 페이지 구현 프롬프트:**

```
블로그 포스트 목록 페이지를 구현해 주세요.

**현재 상황:**
- PostCard 컴포넌트 구현 완료
- 기본 레이아웃 및 네비게이션 구성 완료

**구현 대상:**
- 파일 경로: `app/posts/page.tsx`
- 파일 역할: 모든 블로그 포스트 목록 표시

**주요 요구사항:**
1. 페이지 헤더 섹션
   - 페이지 제목 ("Blog Posts")
   - 간단한 설명 텍스트
   - 전체 포스트 개수 표시

2. 필터링 및 정렬 섹션
   - 카테고리별 필터링 버튼
   - 정렬 옵션 (최신순, 인기순)
   - 검색 박스 (기본 구조만)

3. 포스트 그리드 섹션
   - PostCard 컴포넌트를 활용한 그리드 레이아웃
   - 반응형: 데스크탑 3열, 태블릿 2열, 모바일 1열
   - 페이지당 9개 포스트 표시

4. 페이지네이션 섹션
   - 기본 페이지 번호 네비게이션
   - 이전/다음 버튼
   - 현재 페이지 강조 표시

**기술적 요구사항:**
- 서버 컴포넌트로 기본 구현
- mockData.ts에서 데이터 가져오기
- URL 쿼리 파라미터로 필터링 상태 관리
- TypeScript로 데이터 타입 안전성 확보

**완료 기준:**
- 모든 포스트가 그리드 형태로 정상 표시
- 카테고리 필터링 정상 동작
- 페이지네이션 네비게이션 정상 동작
- 반응형 레이아웃 적절한 동작

```

### 중간 검증: 포스트 목록 테스트

구현된 포스트 목록 기능이 올바르게 작동하는지 확인한다:

1. **기본 기능 테스트**
    - 모든 포스트가 PostCard 형태로 정상 표시되는지 확인
    - 카드 클릭 시 상세 페이지로 이동하는지 확인 (아직 구현 전이므로 404 예상)
    - 카테고리 필터링 버튼 동작 확인
2. **사용자 인터페이스 테스트**
    - 호버 애니메이션 효과 확인
    - 이미지 로딩 및 최적화 상태 확인
    - 텍스트 truncate 및 포맷팅 확인
3. **반응형 테스트**
    - 데스크탑: 3열 그리드 레이아웃 확인
    - 태블릿: 2열 그리드 레이아웃 확인
    - 모바일: 1열 그리드 레이아웃 확인

**검증 결과:**

- 성공한 기능과 수정이 필요한 부분 기록
- 다음 단계 진행을 위한 전제 조건 확인

### 2.3. 3단계: 블로그 포스트 상세 페이지 구현 및 검증

블로그 포스트 상세 페이지를 구현한다.

**동적 라우팅 설정 프롬프트:**

```
블로그 포스트 상세 페이지를 위한 동적 라우팅을 설정해 주세요.

**현재 상황:**
- 포스트 목록 페이지 구현 완료
- PostCard에서 상세 페이지로 링크 연결 필요

**구현 대상:**
- 파일 경로: `app/posts/[slug]/page.tsx`
- 파일 역할: 개별 포스트의 상세 내용 표시

**주요 요구사항:**
1. 동적 라우팅 구현
   - URL slug 파라미터로 포스트 식별
   - generateStaticParams로 정적 경로 생성
   - 존재하지 않는 포스트 접근 시 notFound() 처리

2. 포스트 헤더 섹션
   - 포스트 제목 (h1 태그)
   - 작성자 정보 및 프로필 이미지
   - 작성일, 수정일, 읽기 시간
   - 카테고리 및 태그 표시

3. 포스트 콘텐츠 섹션
   - 커버 이미지 (있는 경우)
   - 마크다운 콘텐츠 렌더링
   - 목차 생성 (선택적)
   - 소셜 공유 버튼

4. 추가 기능 섹션
   - 관련 포스트 추천
   - 댓글 섹션 (다음 단계에서 구현)
   - 좋아요 버튼 (다음 단계에서 구현)

**기술적 요구사항:**
- 서버 컴포넌트로 구현
- mockData.ts에서 slug로 포스트 검색
- Next.js 메타데이터 API로 SEO 최적화
- TypeScript 타입 안전성 확보

**완료 기준:**
- URL slug를 통한 포스트 접근 정상 동작
- 모든 포스트 정보가 적절히 표시
- 존재하지 않는 포스트 접근 시 404 페이지 표시
- SEO 메타데이터 적절히 설정

```

**마크다운 렌더링 컴포넌트 구현 프롬프트:**

```
마크다운 콘텐츠를 렌더링하는 컴포넌트를 구현해 주세요.

**현재 상황:**
- 포스트 상세 페이지 기본 구조 구현 완료
- mockData.ts의 content 필드가 마크다운 형식

**구현 대상:**
- 파일 경로: `components/blog/markdown-content.tsx`
- 파일 역할: 마크다운 텍스트를 HTML로 변환하여 표시

**주요 요구사항:**
1. 마크다운 파싱 및 렌더링
   - react-markdown 라이브러리 활용
   - GitHub Flavored Markdown(GFM) 지원
   - 코드 블록 구문 강조 (highlight.js)

2. 커스텀 컴포넌트 스타일링
   - 제목 태그 (h1-h6) 스타일링
   - 링크 및 이미지 최적화
   - 코드 블록 및 인라인 코드 스타일
   - 인용문 및 목록 스타일

3. TailwindCSS Typography 플러그인 활용
   - prose 클래스 적용
   - 다크 모드 지원 고려
   - 반응형 텍스트 크기

4. 보안 및 XSS 방지
   - HTML 태그 필터링
   - 외부 링크 보안 속성 추가

**기술적 요구사항:**
- 필요한 npm 패키지: react-markdown, rehype-highlight, remark-gfm
- TypeScript Props 인터페이스 정의
- 커스텀 렌더러 함수 구현
- 에러 바운더리 기본 처리

**완료 기준:**
- 마크다운 콘텐츠가 올바르게 HTML로 렌더링
- 코드 블록 구문 강조 정상 동작
- 스타일링이 블로그 디자인과 일관성 유지
- 다양한 마크다운 요소 지원 확인

```

**관련 포스트 컴포넌트 구현 프롬프트:**

```
관련 포스트 추천 컴포넌트를 구현해 주세요.

**현재 상황:**
- 포스트 상세 페이지 및 마크다운 렌더링 구현 완료
- 사용자 경험 향상을 위한 관련 콘텐츠 추천 필요

**구현 대상:**
- 파일 경로: `components/blog/related-posts.tsx`
- 파일 역할: 현재 포스트와 관련된 다른 포스트 추천

**주요 요구사항:**
1. 관련 포스트 추천 로직
   - 동일 카테고리의 다른 포스트 우선 추천
   - 공통 태그가 많은 포스트 추천
   - 현재 포스트는 제외
   - 최대 3개 포스트 표시

2. 카드 레이아웃 구성
   - PostCard 컴포넌트 재사용 또는 간소화된 버전
   - 제목, 요약, 작성일 표시
   - 썸네일 이미지 (작은 크기)

3. 반응형 디자인
   - 데스크탑: 3열 가로 배치
   - 태블릿: 2열 가로 배치 (1개는 다음 줄)
   - 모바일: 1열 세로 배치

4. 빈 상태 처리
   - 관련 포스트가 없는 경우 적절한 메시지 표시
   - 또는 최신 포스트로 대체 추천

**기술적 요구사항:**
- 현재 포스트 정보를 Props로 받기
- mockData.ts에서 관련 포스트 필터링
- 추천 알고리즘 간단한 구현 (태그 일치도 기반)
- TypeScript 타입 안전성 확보

**완료 기준:**
- 적절한 관련 포스트가 추천됨
- 현재 포스트는 추천 목록에서 제외
- 카드 클릭 시 해당 포스트로 이동 정상 동작
- 관련 포스트가 없는 경우 적절한 대체 표시

```

### 중간 검증: 포스트 상세 페이지 테스트

구현된 포스트 상세 페이지가 올바르게 작동하는지 확인한다:

1. **동적 라우팅 테스트**
    - 다양한 포스트 slug로 접근하여 올바른 포스트 표시 확인
    - 존재하지 않는 slug 접근 시 404 페이지 표시 확인
    - 포스트 목록에서 상세 페이지로 네비게이션 확인
2. **콘텐츠 렌더링 테스트**
    - 마크다운 콘텐츠가 올바르게 HTML로 변환되는지 확인
    - 코드 블록 구문 강조 동작 확인
    - 이미지, 링크 등 미디어 요소 표시 확인
3. **관련 포스트 테스트**
    - 동일 카테고리 포스트가 우선 추천되는지 확인
    - 현재 포스트가 추천 목록에서 제외되는지 확인
    - 관련 포스트 카드 클릭 시 정상 이동 확인

**검증 결과:**

- 각 기능별 정상 동작 여부 기록
- 사용자 경험 관점에서 개선점 식별

### 2.4. 4단계: 검색 기능 구현 및 검증 (선택사항)

기본적인 검색 기능을 구현한다.

**검색 UI 컴포넌트 구현 프롬프트:**

```
블로그 검색 기능의 UI 컴포넌트를 구현해 주세요.

**현재 상황:**
- 모든 기본 페이지 구현 완료
- Header에 검색 버튼이 있지만 기능 없음

**구현 대상:**
- 파일 경로: `components/search/search-dialog.tsx`
- 파일 역할: 검색 입력 및 결과 표시 모달

**주요 요구사항:**
1. 검색 다이얼로그 구성
   - ShadCN Dialog 컴포넌트 활용
   - 검색 입력 필드 (placeholder: "포스트 검색...")
   - 실시간 검색 결과 표시
   - 키보드 단축키 지원 (Ctrl+K, Cmd+K)

2. 검색 기능 구현
   - 제목 및 콘텐츠에서 키워드 검색
   - 대소문자 구분 없는 검색
   - 검색어 하이라이팅
   - 최대 5개 결과 표시

3. 검색 결과 표시
   - 포스트 제목, 요약, 작성일
   - 검색어가 포함된 부분 강조
   - 결과 클릭 시 해당 포스트로 이동 및 다이얼로그 닫기

4. 사용자 경험 개선
   - 로딩 상태 표시
   - 검색 결과 없음 메시지
   - 최근 검색어 기록 (로컬 스토리지)

**기술적 요구사항:**
- 'use client' 컴포넌트로 구현
- useState로 검색어 및 결과 상태 관리
- useEffect로 검색어 변경 감지 및 디바운싱
- mockData.ts에서 클라이언트 사이드 검색

**완료 기준:**
- 검색 다이얼로그가 정상적으로 열리고 닫힘
- 실시간 검색이 지연 없이 동작
- 검색 결과 클릭 시 정확한 포스트로 이동
- 키보드 단축키가 모든 페이지에서 동작

```

**검색 결과 페이지 구현 프롬프트:**

```
검색 결과를 표시하는 전용 페이지를 구현해 주세요.

**현재 상황:**
- 검색 다이얼로그 구현 완료
- URL 기반 검색 결과 페이지 필요

**구현 대상:**
- 파일 경로: `app/search/page.tsx`
- 파일 역할: 검색 쿼리에 따른 포스트 결과 표시

**주요 요구사항:**
1. 검색 쿼리 처리
   - URL 쿼리 파라미터에서 검색어 추출 (?q=검색어)
   - 검색어가 없는 경우 검색 폼만 표시
   - 검색 히스토리 및 인기 검색어 표시

2. 검색 결과 표시
   - 검색된 포스트를 PostCard 형태로 표시
   - 검색어가 포함된 부분 하이라이팅
   - 결과 개수 및 검색 소요 시간 표시

3. 필터링 및 정렬
   - 카테고리별 필터 옵션
   - 관련도순, 최신순 정렬 옵션
   - 날짜 범위 필터 (선택적)

4. 빈 상태 및 오류 처리
   - 검색 결과가 없는 경우 안내 메시지
   - 추천 검색어 또는 인기 포스트 제안
   - 검색어 오타 제안 (간단한 구현)

**기술적 요구사항:**
- 서버 컴포넌트와 클라이언트 컴포넌트 적절한 분리
- URL 쿼리 파라미터 처리
- 검색 알고리즘 기본 구현 (제목, 내용, 태그 검색)
- SEO를 위한 적절한 메타데이터 설정

**완료 기준:**
- URL 쿼리를 통한 검색 페이지 접근 정상 동작
- 다양한 검색어로 정확한 결과 반환
- 필터 및 정렬 옵션 정상 동작
- 검색 결과가 없는 경우 적절한 안내

```

### 중간 검증: 검색 기능 테스트

구현된 검색 기능이 올바르게 작동하는지 확인한다:

1. **검색 다이얼로그 테스트**
    - Header의 검색 버튼 클릭 시 다이얼로그 열림 확인
    - 키보드 단축키 (Ctrl+K, Cmd+K) 동작 확인
    - 실시간 검색 결과 표시 확인
2. **검색 정확도 테스트**
    - 다양한 키워드로 검색 결과 정확성 확인
    - 대소문자 구분 없는 검색 동작 확인
    - 검색어 하이라이팅 표시 확인
3. **검색 결과 페이지 테스트**
    - URL을 통한 직접 검색 페이지 접근 확인
    - 필터 및 정렬 옵션 동작 확인
    - 빈 검색 결과에 대한 적절한 처리 확인

**검증 결과:**

- 검색 기능의 정확성 및 사용성 평가
- 성능 이슈 또는 개선점 식별

### 2.5. 5단계: 댓글 기능 구현 및 검증

포스트에 댓글을 작성할 수 있는 기능을 구현한다.

**댓글 데이터 모델 정의 프롬프트:**

```
댓글 시스템을 위한 데이터 모델을 정의해 주세요.

**현재 상황:**
- 포스트 상세 페이지 구현 완료
- 사용자 인터랙션 기능 추가 필요

**구현 대상:**
- 파일 경로: `types/comment.ts`
- 파일 역할: 댓글 관련 TypeScript 타입 정의

**주요 요구사항:**
1. Comment 인터페이스 정의
   - id: 고유 식별자 (string)
   - postId: 댓글이 달린 포스트 ID
   - authorName: 작성자 이름
   - authorEmail: 작성자 이메일 (표시하지 않음, 관리용)
   - content: 댓글 내용
   - createdAt: 작성 시간
   - updatedAt: 수정 시간 (선택적)

2. CommentFormData 인터페이스
   - 댓글 작성 폼에서 사용할 데이터 구조
   - 필수 필드와 선택적 필드 구분

3. 댓글 관련 유틸리티 타입
   - 댓글 목록 정렬 옵션
   - 댓글 상태 (작성 중, 수정 중 등)

**기술적 요구사항:**
- TypeScript 인터페이스 및 타입 정의
- 다른 모듈에서 재사용 가능하도록 export
- JSDoc 주석으로 각 필드 설명 추가

**완료 기준:**
- 댓글 시스템에 필요한 모든 타입 정의 완료
- 타입 안전성을 보장하는 구조
- 향후 데이터베이스 연동 시 확장 가능한 구조

```

**댓글 섹션 컴포넌트 구현 프롬프트:**

```
블로그 포스트의 댓글 섹션 컴포넌트를 구현해 주세요.

**현재 상황:**
- Comment 타입 정의 완료
- 포스트 상세 페이지에 댓글 기능 추가 필요

**구현 대상:**
- 파일 경로: `components/blog/comment-section.tsx`
- 파일 역할: 댓글 목록 표시 및 새 댓글 작성

**주요 요구사항:**
1. 댓글 목록 표시 영역
   - 댓글 개수 표시 ("댓글 5개")
   - 댓글 작성일 기준 최신순 정렬
   - 댓글이 없는 경우 안내 메시지

2. 댓글 작성 폼
   - 작성자 이름 입력 필드
   - 작성자 이메일 입력 필드 (선택적)
   - 댓글 내용 텍스트 영역 (3-4줄)
   - 작성 버튼

3. 댓글 아이템 표시
   - 작성자 이름 및 작성일
   - 댓글 내용
   - 간단한 아바타 (이니셜 기반)

4. 로컬 스토리지 저장
   - 댓글 데이터를 브라우저 로컬 스토리지에 저장
   - 포스트별로 댓글 구분하여 저장
   - 페이지 새로고침 시에도 댓글 유지

**기술적 요구사항:**
- 'use client' 컴포넌트로 구현
- useState로 댓글 목록 및 폼 상태 관리
- 폼 validation 기본 구현
- localStorage API 활용

**완료 기준:**
- 댓글 작성이 정상적으로 동작
- 작성된 댓글이 목록에 즉시 표시
- 페이지 새로고침 후에도 댓글 유지
- 다른 포스트에는 해당 포스트 댓글만 표시

```

**댓글 아이템 컴포넌트 구현 프롬프트:**

```
개별 댓글을 표시하는 컴포넌트를 구현해 주세요.

**현재 상황:**
- 댓글 섹션 구현 완료
- 개별 댓글 표시를 위한 재사용 가능한 컴포넌트 필요

**구현 대상:**
- 파일 경로: `components/blog/comment-item.tsx`
- 파일 역할: 개별 댓글의 정보와 스타일 표시

**주요 요구사항:**
1. 댓글 정보 표시
   - 작성자 아바타 (이름 이니셜 기반)
   - 작성자 이름
   - 작성 시간 (상대적 시간: "2시간 전", "3일 전")
   - 댓글 내용

2. 댓글 액션 (향후 확장)
   - 답글 버튼 (기본 UI만, 기능은 선택적)
   - 좋아요 버튼 (기본 UI만, 기능은 선택적)
   - 신고 버튼 (기본 UI만)

3. 스타일링
   - 카드 형태의 깔끔한 디자인
   - 아바타와 콘텐츠의 적절한 레이아웃
   - 호버 시 미세한 효과

4. 시간 포맷팅
   - 상대적 시간 표시 함수 구현
   - 한국어 기준 시간 표시

**기술적 요구사항:**
- Comment 타입을 Props로 받기
- 시간 포맷팅 유틸리티 함수 구현
- 아바타 생성 로직 구현 (이니셜 + 배경색)
- TailwindCSS로 스타일링

**완료 기준:**
- 댓글 정보가 읽기 쉽게 표시됨
- 아바타가 작성자별로 일관되게 생성됨
- 상대적 시간이 정확하게 표시됨
- 전체 댓글 섹션과 조화로운 디자인

```

### 중간 검증: 댓글 기능 테스트

구현된 댓글 기능이 올바르게 작동하는지 확인한다:

1. **댓글 작성 테스트**
    - 댓글 작성 폼에 정보 입력 후 제출
    - 작성된 댓글이 목록에 즉시 표시되는지 확인
    - 필수 필드 누락 시 적절한 에러 메시지 표시 확인
2. **데이터 영속성 테스트**
    - 댓글 작성 후 페이지 새로고침하여 댓글 유지 확인
    - 다른 포스트로 이동 후 돌아와서 댓글 유지 확인
    - 브라우저 탭을 닫았다 열어도 댓글 유지 확인
3. **사용자 경험 테스트**
    - 댓글이 없는 상태와 있는 상태의 UI 차이 확인
    - 댓글 개수 표시 정확성 확인
    - 시간 표시 포맷의 적절성 확인

**검증 결과:**

- 댓글 시스템의 기본 동작 확인
- 로컬 스토리지 기반 저장의 안정성 평가
- 사용자 인터페이스의 직관성 평가

### 2.6. 6단계: 좋아요 기능 구현 및 검증

포스트에 좋아요를 누를 수 있는 기능을 구현한다.

**좋아요 버튼 컴포넌트 구현 프롬프트:**

```
블로그 포스트의 좋아요 버튼 컴포넌트를 구현해 주세요.

**현재 상황:**
- 댓글 기능 구현 완료
- 포스트 인터랙션 기능 확장 필요

**구임 대상:**
- 파일 경로: `components/blog/like-button.tsx`
- 파일 역할: 포스트 좋아요 기능 및 카운트 표시

**주요 요구사항:**
1. 좋아요 버튼 UI
   - 하트 아이콘 (Lucide React)
   - 좋아요 수 표시
   - 좋아요 상태에 따른 아이콘 색상 변화
   - 클릭 시 애니메이션 효과

2. 좋아요 기능 구현
   - 클릭 시 좋아요 상태 토글
   - 좋아요 수 증가/감소
   - 로컬 스토리지에 사용자별 좋아요 상태 저장
   - 브라우저 세션 기반 사용자 구분

3. 상태 관리
   - 현재 포스트의 좋아요 상태
   - 전체 좋아요 수
   - 로딩 상태 (클릭 시 일시적 비활성화)

4. 사용자 경험 최적화
   - 낙관적 업데이트 (클릭 즉시 UI 변경)
   - 중복 클릭 방지
   - 접근성 고려 (키보드 네비게이션, ARIA 레이블)

**기술적 요구사항:**
- 'use client' 컴포넌트로 구현
- useState, useEffect로 상태 관리
- localStorage API로 데이터 영속성
- postId를 Props로 받아 포스트별 구분

**완료 기준:**
- 좋아요 버튼 클릭 시 상태 즉시 변경
- 페이지 새로고침 후에도 좋아요 상태 유지
- 다른 포스트의 좋아요는 독립적으로 관리
- 시각적 피드백이 명확하고 직관적

```

**포스트 카드에 좋아요 통합 프롬프트:**

```
기존 PostCard 컴포넌트에 좋아요 기능을 통합해 주세요.

**현재 상황:**
- LikeButton 컴포넌트 구현 완료
- 포스트 목록에서도 좋아요 기능 제공 필요

**구현 대상:**
- 파일 경로: `components/blog/post-card.tsx` (기존 파일 수정)
- 파일 역할: 포스트 카드에 좋아요 버튼 추가

**주요 요구사항:**
1. 레이아웃 조정
   - 카드 하단 메타 정보 영역에 좋아요 버튼 추가
   - 작성자, 날짜 정보와 함께 우측에 배치
   - 카드 전체 클릭과 좋아요 버튼 클릭 이벤트 분리

2. 좋아요 버튼 스타일링
   - 카드 크기에 맞는 적절한 버튼 크기
   - 목록에서는 간소한 형태로 표시
   - 호버 및 클릭 피드백

3. 이벤트 처리
   - 좋아요 버튼 클릭 시 카드 클릭 이벤트 전파 방지
   - 좋아요 상태 변경 시 부모 컴포넌트에 알림

**기술적 요구사항:**
- 기존 PostCard 컴포넌트 구조 유지
- LikeButton 컴포넌트 재사용
- 이벤트 버블링 적절한 처리
- TypeScript Props 인터페이스 업데이트

**완료 기준:**
- 포스트 목록에서 좋아요 기능 정상 동작
- 카드 클릭과 좋아요 클릭이 올바르게 분리
- 목록과 상세 페이지 간 좋아요 상태 동기화

```

**포스트 상세 페이지에 좋아요 통합 프롬프트:**

```
포스트 상세 페이지에 좋아요 기능을 통합해 주세요.

**현재 상황:**
- 포스트 카드에 좋아요 기능 통합 완료
- 상세 페이지에도 더 큰 좋아요 버튼 필요

**구현 대상:**
- 파일 경로: `app/posts/[slug]/page.tsx` (기존 파일 수정)
- 파일 역할: 포스트 상세 페이지에 좋아요 기능 추가

**주요 요구사항:**
1. 좋아요 버튼 배치
   - 포스트 제목 근처 또는 댓글 섹션 위에 배치
   - 더 큰 크기와 더 목에 띄는 스타일
   - 소셜 공유 버튼과 함께 배치 (있는 경우)

2. 상세 페이지용 스타일링
   - 목록 페이지보다 더 큰 버튼
   - 좋아요 수를 더 명확하게 표시
   - 클릭 시 더 풍부한 애니메이션

3. 데이터 동기화
   - 목록 페이지와 상세 페이지 간 좋아요 상태 일치
   - 브라우저 뒤로가기 시에도 상태 유지

**기술적 요구사항:**
- LikeButton 컴포넌트 재사용
- 포스트 slug를 통한 고유 식별
- 상세 페이지 레이아웃과 조화로운 배치

**완료 기준:**
- 상세 페이지에서 좋아요 기능 정상 동작
- 목록 페이지와 상세 페이지 간 상태 일치
- 시각적으로 매력적이고 사용하기 쉬운 UI

```

### 중간 검증: 좋아요 기능 테스트

구현된 좋아요 기능이 올바르게 작동하는지 확인한다:

1. **기본 좋아요 기능 테스트**
    - 포스트 목록에서 좋아요 버튼 클릭 시 상태 변경 확인
    - 포스트 상세 페이지에서 좋아요 버튼 클릭 시 상태 변경 확인
    - 좋아요 수 증가/감소 정확성 확인
2. **상태 동기화 테스트**
    - 목록 페이지에서 좋아요 후 상세 페이지로 이동하여 상태 일치 확인
    - 상세 페이지에서 좋아요 후 목록 페이지로 돌아가서 상태 일치 확인
    - 페이지 새로고침 후 좋아요 상태 유지 확인
3. **사용자 경험 테스트**
    - 좋아요 버튼 클릭 시 시각적 피드백 확인
    - 애니메이션 효과 자연스러움 확인
    - 중복 클릭 방지 동작 확인

**검증 결과:**

- 좋아요 시스템의 일관성 및 안정성 평가
- 사용자 인터페이스의 반응성 평가
- 다음 단계 진행을 위한 준비 상태 확인

## 3. 개발 프로세스의 핵심 원칙

### 3.1. 단계별 중간 산출물 검증

AI 주도 개발에서는 각 단계마다 중간 산출물을 철저히 검증하는 것이 중요하다:

1. **문서 검증**: 각 문서가 명확하고 일관되며 구체적인지 확인
2. **코드 검증**: 구현된 코드가 요구사항과 디자인 가이드를 충족하는지 확인
3. **기능 검증**: 구현된 기능이 예상대로 작동하는지 확인
4. **UI/UX 검증**: 사용자 경험이 디자인 가이드와 일치하는지 확인

### 3.2. 설계와 구현의 일치성 확인

개발 과정에서 설계 문서와 실제 구현 사이의 일치성을 지속적으로 확인해야 한다:

1. **요구사항 추적**: 구현된 기능이 요구사항 문서에 명시된 모든 기능을 충족하는지 확인
2. **디자인 일치**: 구현된 UI가 디자인 가이드 및 와이어프레임과 일치하는지 확인
3. **아키텍처 준수**: 코드 구조가 기술 아키텍처 문서와 일치하는지 확인
4. **비기능적 요구사항 충족**: 성능, 접근성, 보안 등 비기능적 요구사항이 충족되는지 확인

### 3.3. 디버깅 및 오류 처리 방법

개발 과정에서 발생하는 오류를 체계적으로 처리하는 방법:

1. **오류 로깅**: 발생한 오류를 세부적으로 기록
2. **근본 원인 분석**: 오류의 근본 원인을 파악하기 위한 단계별 접근
3. **AI 피드백 활용**: 오류 해결을 위해 AI에게 구체적인 질문 제시
4. **해결책 검증**: 구현된 해결책이 오류를 완전히 해결했는지 확인

### 3.4. 확장 가능한 코드 구조 유지

미래의 확장을 고려한 코드 구조를 유지하는 방법:

1. **모듈화**: 기능별로 코드를 모듈화하여 재사용성과 유지보수성 향상
2. **인터페이스 정의**: 명확한 인터페이스 정의로 컴포넌트 간 결합도 최소화
3. **설계 패턴 적용**: 적절한 설계 패턴을 적용하여 코드 구조 개선
4. **지속적인 리팩토링**: 코드 중복 제거 및 구조 개선을 위한 지속적인 리팩토링

## 4. 진행 상황 저장 (GitHub 커밋)

이 장에서 구현한 내용을 GitHub에 안전하게 저장한다.

**단계별 저장 방법:**

1. **현재 상태 확인**
    
    ```bash
    git status
    
    ```
    
    - 수정된 파일들 확인
    - 새로 생성된 파일들 확인
2. **변경사항 스테이징**
    
    ```bash
    git add .
    
    ```
    
    - 모든 변경된 파일을 커밋 준비 상태로 추가
3. **커밋 메시지 작성 및 커밋**
    
    ```bash
    git commit -m "8장 완료: 블로그 기본 구조 및 주요 기능 구현"
    
    ```
    
4. **GitHub에 업로드**
    
    ```bash
    git push origin main
    
    ```
    

**커밋 세부 내용:**

- 기본 레이아웃 (Header, Footer, Layout) 구현
- 블로그 포스트 목록 및 상세 페이지 구현
- 검색 기능 기본 구현
- 댓글 시스템 (로컬 스토리지 기반) 구현
- 좋아요 기능 구현
- 반응형 디자인 적용

**문제 발생 시:**

- 충돌(conflict) 발생 시: VS Code에서 충돌 해결 후 다시 커밋
- 푸시 실패 시: `git pull origin main` 후 다시 푸시

## 5. 최종 검증: 8장 전체 기능 테스트

이 장에서 구현한 모든 기능을 종합적으로 테스트한다:

1. **핵심 기능 점검**
    - 블로그 기본 레이아웃 정상 작동 확인
    - 포스트 목록 및 상세 페이지 정상 표시 확인
    - 검색 기능 정상 동작 확인
    - 댓글 작성 및 표시 기능 확인
    - 좋아요 기능 정상 동작 확인
2. **사용자 경험 전반 확인**
    - 네비게이션의 직관성 및 일관성 확인
    - 반응형 디자인이 모든 디바이스에서 적절히 동작하는지 확인
    - 로딩 상태 및 에러 처리가 사용자 친화적인지 확인
3. **다음 장 준비 상태 점검**
    - 9장 인증 시스템 통합을 위한 기본 구조 확인
    - 필요한 컴포넌트와 데이터 구조가 준비되었는지 확인
    - 향후 데이터베이스 연동을 위한 확장 가능성 확인

**종합 평가:**

- 구현된 기능의 완성도 및 안정성
- 코드 품질 및 유지보수성
- 사용자 경험의 일관성 및 직관성
- 다음 단계 개발을 위한 준비 상태

8장을 통해 블로그의 핵심 기능과 구조가 완성되었다. 다음 9장에서는 Clerk를 활용한 사용자 인증 시스템을 통합하여 더욱 완전한 블로그 플랫폼으로 발전시킬 예정이다.